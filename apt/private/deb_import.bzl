"deb_import"

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load(":util.bzl", "util")

_DEB_IMPORT_BUILD_TMPL = '''
genrule(
    name = "data",
    srcs = glob(["data.tar*"]),
    outs = ["layer.tar.gz"],
    cmd = """
    # Per the dpkg-dev man page:
    # https://manpages.debian.org/bookworm/dpkg-dev/deb.5.en.html
    #
    # Debian data.tar files can be:
    #  - .tar uncompressed, supported since dpkg 1.10.24
    #  - .tar compressed with
    #    *  gzip: .gz
    #    * bzip2: .bz2, supported since dpkg 1.10.24
    #    *  lzma: .lzma, supported since dpkg 1.13.25
    #    *    xz: .xz, supported since dpkg 1.15.6
    #    *  zstd: .zst, supported since dpkg 1.21.18
    #
    # ZSTD_BIN can decompress all formats except bzip2
    #
    # The OCI image spec supports .tar and .tar compressed with gzip or zstd.
    # Bazel needs the output filename to be fixed in advanced so we settle for
    # gzip compression.

    data_file="$$(basename $<)"

    if [[ "$$data_file" == "data.tar.bz2" ]]; then
      # TODO: support bz2
      echo "ERROR: unsupported compression: bz2"
      exit 1
    elif [[ "$$data_file" == "data.tar.gz" ]]; then
      mv $< $@
    elif [[ "$$data_file" == "data.tar" ]]; then
      $(ZSTD_BIN) --compress --format=gzip $< >$@
    else
      $(ZSTD_BIN) --force --decompress --stdout $< |
      $(ZSTD_BIN) --compress --format=gzip - >$@
    fi
    """,
    toolchains = ["@zstd_toolchains//:resolved_toolchain"],
    visibility = ["//visibility:public"],
)

filegroup(
    name = "control",
    srcs = glob(["control.tar.*"]),
    visibility = ["//visibility:public"],
)
'''

def make_deb_import_key(repo_name, package):
    return "{}_{}_{}_{}".format(
        repo_name,
        util.sanitize(package.name),
        package.arch,
        util.sanitize(package.version),
    )

def deb_import(name, url, sha256):
    http_archive(
        name = name,
        url = url,
        sha256 = sha256,
        build_file_content = _DEB_IMPORT_BUILD_TMPL,
    )

def _deb_import_tmpl(repo_name, package):
    deb_import_key = make_deb_import_key(repo_name, package)

    return '''\
    deb_import(
        name = "{name}",
        url = "{url}",
        sha256 = "{sha256}",
    )
'''.format(name = deb_import_key, url = package.url, sha256 = package.sha256)

def deb_packages(repo_name, packages):
    deb_imports = [
        _deb_import_tmpl(repo_name, package)
        for architectures in packages.values()
        for package in architectures.values()
    ]

    return '''\
"""Generated by rules_distroless. DO NOT EDIT."""
load("@rules_distroless//apt/private:deb_import.bzl", "deb_import")

# buildifier: disable=function-docstring
def {repo_name}_packages():
{deb_imports}
'''.format(
        repo_name = repo_name,
        deb_imports = "\n".join(deb_imports) if deb_imports else "    pass",
    )

def _deps_str(dependencies, arch, depth):
    return ("\n" + " " * depth).join([
        '"//%s/%s",' % (dep.name, arch)
        for dep in dependencies
    ])

def package_arch_build(package, repo_prefix, repo_name, arch_template):
    deb_import_key = make_deb_import_key(repo_name, package)

    deps = '[":data"]'
    if package.dependencies:
        deps += """ + [
        {deps}
    ]""".format(deps = _deps_str(package.dependencies, package.arch, 8))
    deps += ","

    return arch_template.format(
        target_name = package.arch,
        src = '"@%s%s//:data"' % (repo_prefix, deb_import_key),
        deps = deps,
        urls = [package.url],
        name = package.name,
        arch = package.arch,
        sha256 = package.sha256,
        repo_name = "%s%s" % (repo_prefix, deb_import_key),
    )

def _gen_alias_select(name, package_name, architectures):
    if len(architectures) == 1 and architectures.keys()[0] == "all":
        actual = '"//{package_name}/all:{name}"'
    else:
        actual = "select({{"
        for arch in architectures:
            actual += "\n" + " " * 8
            actual += '"@platforms//cpu:%s": ' % util.arch_to_cpu(arch)
            actual += '"//{package_name}/%s:{name}",' % arch
        actual += "\n    }})"

    actual = actual.format(
        package_name = package_name,
        name = name,
    )

    return """\
alias(
    name = "{name}",
    actual = {actual},
    visibility = ["//visibility:public"],
)
""".format(name = name, actual = actual)

def _gen_filegroup_select(package_name, architectures):
    srcs = '[":data"]'

    if len(architectures) == 1 and architectures.keys()[0] == "all":
        package = architectures["all"]
        if package.dependencies:
            srcs += """ + [
        {deps}
    ]""".format(deps = _deps_str(package.dependencies, "all", 8))
    else:
        selects = []
        for arch, package in architectures.items():
            if not package.dependencies:
                continue

            select = """
        "@platforms//cpu:{cpu}": [
            {deps}
        ],""".format(
                cpu = util.arch_to_cpu(arch),
                deps = _deps_str(package.dependencies, arch, 12),
            )
            selects.append(select)

        if selects:
            srcs += " + select({"
            srcs += "".join(selects)
            srcs += "\n    })"

    srcs += ","

    return """\
filegroup(
    name = "{name}",
    srcs = {srcs}
    visibility = ["//visibility:public"],
)
""".format(name = package_name, srcs = srcs)

def package_aliases_build(package_name, architectures):
    aliases = [
        _gen_alias_select(name, package_name, architectures)
        for name in ("data", "control")
    ]

    filegroup = _gen_filegroup_select(package_name, architectures)

    return '''\
"""Generated by rules_distroless. DO NOT EDIT."""

{aliases}

{filegroup}
'''.format(aliases = "\n".join(aliases), filegroup = filegroup)
